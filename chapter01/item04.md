# 객체 생성과 파괴


### item04. 인스턴스화를 막으려거든 private 생성자를 사용하라

개발을 하다보면 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것이다. 객체 지향적으로 사고하지 않는 이들이 종종 남용하는 방식이기에 그리 곱게 보이지는 않지만, 분명 나름의 쓰임새가 있다.

예를들어 java.lang.Math 나 java.lang.Arrays처럼 기본 타입 값이나 배열 관렴 메서드들을 모아놓을 수 있다.

```
System.out.println(Math.abs(-4));
```
이처럼 Math 클래스에 선언되어 있는 정적 메소드들은 어디서나 호출이 가능하게 되어 있으며 이는 편리함을 제공한다.

정적 멤버만 담은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한 것이 아니지만 생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어 준다.

때문에 의도치 않게 인스턴스화 할 수 있게 된 클래스가 종족 목격되기도 한다.

**추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.**   
이는 하위클래스를 만들어 인스턴스화를 할 수 있기 때문이다. 또한 이를 본 사용자는 상속해서 쓰라는 뜻으로 오해를 할 수 있기 때문에 더 큰 문제이다.

이를 해결하기 위해서 우리는 **private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.**

```
public class Main{
    public static void main(String [] args) {
        Utility u = new Utility(); // 컴파일애러
        int a = Utility.NUM; //인스턴스화 하지 않고 사용해야 한다.
    }
}

class Utility {
    static int NUM = 1;
    static String STR = "TEST";
    
    // 인스턴스화를 막아준다.
    private Utility() {}
}
```