# 객체 생성과 파괴


### item08. finalizer와 cleaner 사용을 피하라

자바에서는 두 가지의 객체 소멸자를 제공한다. **그중 finalizer는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다. 즉 기본적으로 '쓰지 말아야' 한다.**  
때문에 자바9에서는 이를 deprecated 하였고, 대안으로 cleaner를 대안으로 하였지만 이 역시 여전히 예측할 수 없고, 느리고, 불필요하다.

자바의 소멸자는 c++의 소멸자와 다른 개념이다. c++에서는 개발자가 소멸자를 호출하여 자원을 회수하는 방식을 사용하지만 자바에서는 이를 가비지 컬렉터가 담당하여 개발자에게는 아무런 작업도 요구하지 않는다.

또한 finalizer와 cleaner는 즉시 수행된다는 보장이 없다. 예컨데 파일 닫기를 finalizer나 cleaner에 맡기면 중대한 오류를 일으킬 수 있다. 그리고 가비지 컬렉터 마다 이를 수행하는 알고리즘이 달라 자바 버전에 따라 문제를 일으킬 수도 그렇지 않을 수도 있기 때문에 이 방식을 지양해야 한다.

>* 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해선 안된다.  
>* finalizer와 cleaner는 심각한 성능 문제도 동반한다.  
>* finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다. 

그렇다면 이에 대한 대응책은 무엇일까?

우리는 AutoCloseable을 구현해주고 클라이언트에서 인스턴스를 다 쓰고 나면 close 메서드를 호출하면 된다. 즉 try with resource를 활용할 수 있도록 AutoCloseable 인터페이스의 close 메소드를 오버라이딩하여 구현해 주면 된다.

이렇게 된다면 인스턴스를 모두 쓴 후에 close 메소드를 호출하여 자원을 다시 회수 할 수 있도록 할 수 있다.

```
public abstract class InputStream implements Closeable {...
```

Input 스트림 클래스 또한 Closeable 인터페이스의 close 메소드를 오버라이딩 한 것을 확인 할 수 있다.

> cleaner(자바8 까지는 finalizer)는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 사용하자. 물론 이런 경우라도 불확실성과 성능 저하에 주의해야 한다.

