# 객체 생성과 파괴


### item05. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

많은 클래스가 하나 이상의 자원에 의존한다.

```
class Car {
    private final Type type = ...
    private Car() {}
}
```

비슷하게 싱글턴으로도 구현이 가능하다.

```
class Car {
    private final Type type = ...
    private Car() {}

    public static Car INSTANCE = new Car();
}
```

위의 예제의 문제는 무엇일까?

자동차의 종류는 하나만 있는 것이 아닌데, 자원을 직접 명시함으로써 이 하나로 자동차의 타입을 정의하기가 힘들다. 

(... 으로 명시 된 부분이 타입을 지정하는 코드로 이해하면 된다.)

tpye는 bus 외로도 van 이라던가 suv 등 여러가지 타입의 자동차가 있을 수 있기 때문이다.

그렇다면 이 Car 클래스를 여러가지 타입을 가질 수 있도록 바꾸어 보자.

**사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.**

대신 클래스가 여러 자원 인스턴스를 지원해야 하며, 클라이언트가 원하는 자원을 사용해야 한다.

즉 Car 클래스는 여러 자원을 지원해야 하고, 클라이언트가 원하는 자원인 type를 사용 가능하게 해야 한다.

이 조건을 만족하는 간단한 패턴이 있으니 **인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식**이다.

의존 객체 주입의 한 형태로, 스프링에서 의존성 주입의 패턴이 바로 이 패턴이다.

```
public class Main{
    public static void main(String [] args) {
        Type bus = new Type();
        Car car = new Car(bus);
    }
}

class Car {
    private final Type type = ...;
    
    public Car(Type type) {
        this.type = type;
    }
}

class Type {
}
```

예에서 볼 수 있듯 우리는 bus라는 타입을 의존성 주입하여 Car의 인스턴스를 생성하였다.

이에대한 장점으로는

>1. 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 작동한다.
>2. 불변을 보장한다.
>3. 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있다.
>4. 의존 객체 주입은 생성자, 정적 팩터리, 빌더에 모두 똑같이 응용 가능하다.

의존 객체 주입이 유연성과 테스트를 개선해주지만 의존성이 수천개가 되는 거대한 프로젝트는 코드를 어지럽게 만들기도 한다.

하지만 스프링 같은 의존 객체 주입 프레임워크를 사용하여 이를 해결 가능하다.

> 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.
> 이 자원들은 클래스가 직접 만들게 해서도 안 된다. 대신 필요한 자원을 생성자에 넘겨주자.