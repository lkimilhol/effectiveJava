# 객체 생성과 파괴


### item06. 불필요한 객체 생성을 피하라

똑같은 객체를 매번 생성하기보다 객체 하나를 재사용하는 편이 나을 때가 많다.

```
String s = new String("hi");
```

위의 코드는 실행이 될 때 마다 String 인스턴스를 새로 만든다. 재사용이 전혀 되지 않는다는 의미다.

이 문장이 호출 될 때마다 String 인스턴스는 계속해서 생성이 된다. 개선된 버전을 보자.

```
String s = "hi";
```

이 코드는 하나의 String 인스턴스를 사용한다. 이와 똑같은 문자열 리터럴을 사용하는 모든 코드가 같은 객체를 재사용함이 보장된다. (String 클래스의 객체는 힙 영역에 인스턴스를 생성해서 계속 재사용한다)

생성자 대신 정적 팩터리 메서드를 제공하는 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.

예를들어 Boolean(String) 생성자 대신 Boolean.ValueOf(String) 팩터리 메서드를 사용하는 것이 좋다.

생성자는 호출할 때마다 새로운 객체를 만들지만, 팩터리 메서드는 전혀 그렇지 않다.

생성 비용이 아주 비싼 경우에는 재사용하기를 추천한다.

```
static boolean checkIpAddress(String s) {
    return s.matches(
        "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
        "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$"
    );
}
```
위의 함수의 경우에는 IP를 체크하는 정규식이다. String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기엔 적합하지 않다.

성능을 개선하기 위해 인스트를 클래스 초기화 과정에서 직접 생성해 캐싱해두고, 나중에 이 인스턴스를 재사용한다.

```
class Ip {
    private static final Pattern IP = Pattern.compile(
            "^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
            "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
            "([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
            "([01]?\\d\\d?|2[0-4]\\d|25[0-5])$"
    );

    static boolean isIpAddress(String s) {
        return IP.matcher(s).matches();
    }
}
```
이렇게하면 계속해서 정규식을 번번히 사용하는 경우 성능상의 큰 개선이 될 뿐만 아니라 코드도 더욱 명확해졌다.

불필요한 객체를 만들어내는 또 다른 예로 오토박싱을 들 수 있다.

```
private static long sum() {
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
        sum += 1;
    }
    return sum;
}
```
sum 변수를 long이 아닌 Long으로 선언해서 불필요한 Long 인스턴스가 231개나 만들어진다.
(타입을 long으로 바꿔주면 속도가 훨씬 빨라진다)

또한 데이터베이스의 연결같은 경우 생성 비용이 비싸니 풀을 이용해 재사용 하는것이 낫지만 별다른 이유 없이는 pool 사용을 권장하지 않는다.

